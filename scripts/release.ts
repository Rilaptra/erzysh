import { readFileSync, writeFileSync } from "fs";
import { join } from "path";
import { execSync } from "child_process";

// Paths
const rootDir = process.cwd();
const cargoPath = join(rootDir, "ghost-agent", "Cargo.toml");
const changelogPath = join(rootDir, "ghost-agent", "CHANGELOG.md");
const versionTsPath = join(rootDir, "src", "lib", "version.ts");

function run(command: string) {
  try {
    console.log(`üíª Executing: ${command}`);
    execSync(command, { stdio: "inherit", cwd: rootDir });
  } catch (e) {
    console.error(`‚ùå Failed to execute: ${command}`);
    process.exit(1);
  }
}

function getFormattedDate() {
  const date = new Date();
  return date.toISOString().split("T")[0]; // YYYY-MM-DD
}

function bumpVersion() {
  try {
    // 1. Read Cargo.toml
    console.log("üì¶ Reading Cargo.toml...");
    let cargoContent = readFileSync(cargoPath, "utf-8");
    const versionMatch = cargoContent.match(/version\s*=\s*"([^"]+)"/);

    if (!versionMatch || !versionMatch[1]) {
      throw new Error("Could not find version in Cargo.toml");
    }

    const currentVersion = versionMatch[1];
    const parts = currentVersion.split(".").map(Number);
    parts[2]++; // Increment patch
    const newVersion = parts.join(".");

    console.log(`üöÄ Bumping version: ${currentVersion} -> ${newVersion}`);

    // 2. Update Cargo.toml
    cargoContent = cargoContent.replace(
      /version\s*=\s*"[^"]+"/,
      `version = "${newVersion}"`,
    );
    writeFileSync(cargoPath, cargoContent);

    // 3. Update CHANGELOG.md
    console.log("üìù Updating CHANGELOG.md...");
    let changelogContent = readFileSync(changelogPath, "utf-8");
    const date = getFormattedDate();

    // Check if the current version is already in changelog (idempotency)
    if (!changelogContent.includes(`[${newVersion}]`)) {
      const newEntry = `## [${newVersion}] - ${date}

### Added
- Auto-generated release.

`;
      // Insert after the first header or specific marker
      // Simple strategy: Find the first occurrence of "## [" and insert before it
      const firstSectionIndex = changelogContent.indexOf("## [");

      let newChangelog = "";
      if (firstSectionIndex !== -1) {
        newChangelog =
          changelogContent.substring(0, firstSectionIndex) +
          newEntry +
          changelogContent.substring(firstSectionIndex);
      } else {
        // Fallback for empty or initialized changelog
        newChangelog = changelogContent + "\n" + newEntry;
      }

      writeFileSync(changelogPath, newChangelog);
    }

    // 4. Update src/lib/version.ts
    console.log("üîÑ Syncing version.ts...");
    const tsContent = `// This file is auto-generated by scripts/release.ts
export const GHOST_VERSION = "${newVersion}";
export const BUILD_DATE = "${new Date().toISOString()}";
`;
    writeFileSync(versionTsPath, tsContent);

    // 5. Git Commit & Tag
    console.log("üíæ Committing to Git...");
    run("git add .");
    run(`git commit -m "chore(release): bump to v${newVersion}"`);
    run(`git tag v${newVersion}`);

    console.log("‚òÅÔ∏è Pushing to GitHub...");
    run("git push origin main"); // Assuming main branch
    run(`git push origin v${newVersion}`);

    console.log(`\n‚ú® Successfully released v${newVersion}!`);
    console.log(
      "GitHub Actions should now pick up the tag and create a Release.",
    );
  } catch (error) {
    console.error("‚ùå Error during release:", error);
    process.exit(1);
  }
}

bumpVersion();
